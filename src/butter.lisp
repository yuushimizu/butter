(in-package :butter)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defmacro with-gensyms ((&rest vars) &rest body)
    `(let ,(loop for var in vars collect `(,var (gensym ,(princ-to-string var)))) ,@body))
  (defclass test-context ()
    ((name :initarg :name :reader test-context-name)
     (parent :initarg :parent :initform nil :reader test-context-parent)))
  (define-condition test-condition (condition)
    ((context :initarg :context :reader test-condition-context)))
  (define-condition test-succeeded (test-condition) ())
  (define-condition test-failed (test-condition)
    ((message :initarg :message :reader test-failed-message))
    (:report (lambda (condition stream)
               (format stream "The test ~A was failed with the message ~S." (test-context-name (test-condition-context condition)) (test-failed-message condition)))))
  (defgeneric test-condition-succeeded-p (condition)
    (:method (condition) nil)
    (:method ((condition test-succeeded)) t))

  (define-condition test-context-required (condition) ())
  (defun call-with-test-handler (test-name function)
    (flet ((make-context ()
             (make-instance 'test-context
                            :name test-name
                            :parent (restart-case
                                        (progn (signal 'test-context-required)
                                               nil)
                                      (continue-with-context (context) context)))))
      (restart-case
          (handler-bind ((test-context-required (lambda (condition)
                                                  (declare (ignore condition))
                                                  (invoke-restart 'continue-with-context (make-context)))))
            (funcall function))
        (success-test ()
          (signal 'test-succeeded :context (make-context))
          nil)
        (fail-test (&optional (message ""))
          (signal (make-condition 'test-failed :context (make-context) :message message))
          nil))))
  (defmacro with-test-handler (test-name &body body)
    `(call-with-test-handler ',test-name (lambda () ,@body)))
  (defmacro in-test (test-name &body body)
    (with-gensyms (message%)
      `(with-test-handler ,test-name
         (flet ((success () (invoke-restart 'success-test))
                (fail (,message%) (invoke-restart 'fail-test ,message%)))
           (declare (ignorable (function success) (function fail)))
           ,@body))))
  
  (defgeneric test-form-expand (type arguments))
  (defmacro define-macro-test-type (type (&rest lambda-list) &body body)
    (with-gensyms (type% arguments%)
      `(eval-when (:compile-toplevel :load-toplevel :execute)
         (defmethod test-form-expand ((,type% (eql ',type)) ,arguments%)
           (declare (ignore ,type%))
           (destructuring-bind ,lambda-list ,arguments% ,@body))
         ',type)))
  (defmacro define-test-type (type (&rest lambda-list) &body body)
    (with-gensyms (type% arguments%)
      `(eval-when (:compile-toplevel :load-toplevel :execute)
         (defmethod test-form-expand ((,type% (eql ',type)) ,arguments%)
           (destructuring-bind ,lambda-list ,arguments%
             `(in-test (,,type% ,@,arguments%)
                       ,,@body
                       (success)))))))
  (defmacro test (type &rest arguments)
    (test-form-expand type arguments))
  (defmacro tests (&rest argument-lists)
    `(progn ,@(mapcar (lambda (arguments) `(test ,@arguments)) argument-lists)))
  
  (define-test-type t (expression)
    `(unless ,expression (fail ,(format nil "~S is nil." expression))))
  (defmethod test-form-expand ((type cons) arguments)
    (funcall #'test-form-expand (car type) (append (cdr type) arguments)))
  (define-macro-test-type nil (&rest arguments)
    `(test ,@arguments))
  (defun calling-form (name arguments)
    (if (symbolp name)
        `(,name ,@arguments)
        `(funcall ,name ,@arguments)))
  (defun call-with-function-fail-handler (function fail-function function-name arguments)
    (handler-bind ((test-failed (lambda (condition)
                                  (declare (ignore condition))
                                  (funcall fail-function (format nil "(~A~{ ~S~}) is nil." function-name arguments)))))
      (funcall function)))
  (define-test-type :function (function-name &rest arguments)
    (let ((argument-variables (mapcar (lambda (argument) (if (keywordp argument) argument (gensym (princ-to-string argument))))
                                      arguments)))
      `(let ,(mapcan (lambda (variable argument) `((,variable ,argument))) argument-variables arguments)
         (call-with-function-fail-handler (lambda () (test t ,(calling-form function-name argument-variables)))
                                          #'fail ',function-name (list ,@argument-variables)))))
  (defun call-with-resignal-handler (function success-function fail-function)
    (handler-bind ((test-succeeded (lambda (condition)
                                     (declare (ignore condition))
                                     (funcall success-function)))
                   (test-failed (lambda (condition)
                                  (funcall fail-function (test-failed-message condition)))))
      (funcall function)))
  (defmethod test-form-expand ((type symbol) arguments)
    `(in-test (,type ,@arguments)
              (call-with-resignal-handler (lambda () (test :function ,type ,@arguments))
                                          #'success
                                          #'fail)))

  (define-macro-test-type :each (test-type &rest argument-lists)
    `(tests ,@(mapcar (lambda (arguments) (cons test-type arguments)) argument-lists)))
  (define-macro-test-type call-single (function &rest arguments)
    (labels ((split-arguments (&optional (rest arguments) (left ()))
               (if (or (not rest) (eq '<- (car rest)))
                   (values (reverse left) (cdr rest))
                   (split-arguments (cdr rest) (cons (car rest) left)))))
      (multiple-value-bind (test-arguments function-arguments) (split-arguments arguments)
        `(test ,@test-arguments ,(calling-form function function-arguments)))))
  (define-macro-test-type :call (function test-type &rest argument-lists)
    `(test :each (call-single ,function ,test-type) ,@argument-lists))
  (define-macro-test-type macro-single ((&rest lambda-list) expansion &rest arguments)
    (with-gensyms (macro%)
      `(macrolet ((,macro% ,lambda-list (cons 'test ,expansion))) (,macro% ,@arguments))))
  (define-macro-test-type :macro ((&rest lambda-list) expansion &rest argument-lists)
    `(test :each (macro-single ,lambda-list ,expansion) ,@argument-lists))
  (define-test-type :type (type value) `(test typep ,value ',type))
  (define-test-type :condition (condition-type &body body)
    `(handler-case (progn ,@body (fail ,(format nil "An expected condition ~A was not signalled." condition-type)))
       (,condition-type ())))
  
  (define-condition no-test-found (error)
    ((test-name :initarg :test-name :reader test-name)))
  (let ((test-functions-in-packages (make-hash-table :test 'equal)))
    (defun test-functions (package)
      (or (gethash (package-name package) test-functions-in-packages)
          (setf (gethash (package-name package) test-functions-in-packages) (make-hash-table)))))
  (defun test-function (name &optional (package *package*))
    (or (gethash name (test-functions package))
        (error 'no-test-found :test-name name)))
  (defun (setf test-function) (function name &optional (package *package*))
    (let ((test-functions (test-functions package)))
      (setf (gethash name test-functions) function)))
  (defmacro deftest (name &body body)
    `(progn
       (setf (test-function ',name) (lambda () (in-test ,name ,@body)))
       ',name))
  (defun run-test (name package)
    (funcall (test-function name package)))
  (defun test-names (&optional (package *package*))
    (loop for name being each hash-key in (test-functions package) collect name)))
